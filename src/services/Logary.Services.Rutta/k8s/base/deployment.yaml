kind: Deployment
apiVersion: apps/v1
metadata:
  name: rutta

  annotations:
    sidecar.jaegertracing.io/inject: jaeger

spec:
  replicas: 2

  template:
    metadata:
      annotations:
        prometheus.io/path: /metrics
        prometheus.io/scrape: "true"
        prometheus.io/port: "9114"

    spec:
      affinity:
        # https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#always-co-located-in-the-same-node
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
              - key: app
                operator: In
                values:
                - rutta # see your kustomization.yaml file
            topologyKey: kubernetes.io/hostname

          # https://blog.verygoodsecurity.com/posts/kubernetes-multi-az-deployments-using-pod-anti-affinity/
          preferredDuringSchedulingIgnoredDuringExecution:
          - podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values:
                  - rutta # see your kustomization.yaml file
              topologyKey: failure-domain.beta.kubernetes.io/zone
            weight: 100

      containers:
      - name: rutta
        image: logary/rutta

        ports:
        - name: http
          containerPort: 3000

        # The kubelet uses readiness probes to know when a container is ready to start accepting traffic.
        readinessProbe:
          httpGet:
            path: /
            port: http
        # Many applications running for long periods of time eventually transition to broken states, and cannot recover except by being restarted. Kubernetes provides liveness probes to detect and remedy such situations.
        livenessProbe:
          httpGet:
            path: /
            port: http

        resources:
          limits:
            cpu: 1000m
            memory: 500Mi
          requests:
            cpu: 10m
            memory: 20Mi